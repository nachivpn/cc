module CC.Cat (Node : Set) (Edge : Node → Node → Set) where

-- Reference: I Beylin and P Dybjer (1995)

open import Relation.Binary.Construct.Closure.Equivalence
  using (EqClosure ; symmetric)
  renaming (isEquivalence to EqClosureIsEquivalence)
open import Function
  using ()
  renaming (id to idf ; _∘_ to _∘f_)

Ty = Node

private
  variable
    a b c : Ty

infixr 4 _∙_

data Tm : (a b : Ty) → Set where
  var   : Edge a b → Tm a b
  id    : Tm a a
  _∙_   : Tm b c → Tm a b → Tm a c

infix 3 _≈_ _∼_

private
  variable
    f g h : Tm a b

data _∼_ : Tm a b → Tm a b → Set where
  idl-∼   : id ∙ f ∼ f
  idr-∼   : f ∼ f ∙ id
  assoc-∼ : (f ∙ g) ∙ h ∼ f ∙ (g ∙ h)

_≈_  : Tm a b → Tm a b → Set
_≈_   = EqClosure _∼_

-- Obs: Tm/≈ gives the free category generated by a graph whose nodes
-- are given by `Ty` and edges are given by `Var`

data 𝒩 : (a b : Ty) → Set where
  id      : 𝒩 a a
  var⟨_⟩∙_ : Edge b c → 𝒩 a b → 𝒩 a c

Tm' : Ty → Ty → Set
Tm' a b  = 𝒩 a b

⟦_⟧→̇⟦_⟧ : Ty → Ty → Set
⟦ a ⟧→̇⟦ b ⟧ = {c : Ty} → (Tm' c a → Tm' c b)

eval : Tm a b → ⟦ a ⟧→̇⟦ b ⟧
eval (var x)    = var⟨ x ⟩∙_
eval id         = idf
eval (t ∙ u)    = (eval t) ∘f (eval u)

emb𝒩 : 𝒩 a b → Tm a b
emb𝒩 id           = id
emb𝒩 (var⟨ x ⟩∙ t) = var x ∙ emb𝒩 t

quot : ⟦ a ⟧→̇⟦ b ⟧ → Tm a b
quot f = emb𝒩 (f id)

norm : Tm a b → Tm a b
norm t = quot (eval t)
